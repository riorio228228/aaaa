<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>3D 空間構造シミュレーション</title>
<style>
  body { margin:0; overflow:hidden; background:#cfe8ff; }
  #ui {
    position:fixed;
    top:10px; left:10px;
    color:#000;
    background:rgba(255,255,255,.85);
    padding:8px;
    font-family:sans-serif;
    font-size:13px;
  }
</style>
</head>
<body>
<div id="ui">
3D構造観察ツール<br>
矢印キー：移動 / Space：上昇<br>
ドラッグ：視点変更<br>
クリック：構造削除
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* 3D空間セットアップ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcfe8ff);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 2, 6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.HemisphereLight(0xffffff, 0x666666, 1));

/* 構造ブロック */
const objects = [];
const geo = new THREE.BoxGeometry(1,1,1);
const mat = new THREE.MeshLambertMaterial({color:0x88aa88});

// 観察用グリッド（狭く）
for(let x=-5;x<=5;x++){
  for(let z=-5;z<=5;z++){
    const o = new THREE.Mesh(geo, mat);
    o.position.set(x,0,z);
    scene.add(o);
    objects.push(o);
  }
}

/* 視点操作（ドラッグ） */
let drag=false, px=0, py=0;
let yaw=0, pitch=0;

addEventListener("mousedown",e=>{
  drag=true; px=e.clientX; py=e.clientY;
});
addEventListener("mouseup",()=>drag=false);
addEventListener("mousemove",e=>{
  if(!drag) return;
  yaw -= (e.clientX-px)*0.003;
  pitch -= (e.clientY-py)*0.003;
  pitch = Math.max(-1.3, Math.min(1.3, pitch));
  px=e.clientX; py=e.clientY;
});

/* 移動（矢印キー） */
const key = {};
addEventListener("keydown",e=>key[e.code]=true);
addEventListener("keyup",e=>key[e.code]=false);

let vy=0, onSurface=false;

/* 構造操作 */
const ray = new THREE.Raycaster();
addEventListener("click",()=>{
  ray.setFromCamera({x:0,y:0}, camera);
  const hit = ray.intersectObjects(objects);
  if(hit.length){
    scene.remove(hit[0].object);
    objects.splice(objects.indexOf(hit[0].object),1);
  }
});

/* ループ */
function loop(){
  requestAnimationFrame(loop);

  camera.rotation.order="YXZ";
  camera.rotation.y=yaw;
  camera.rotation.x=pitch;

  const f = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const r = new THREE.Vector3(f.z,0,-f.x);

  if(key["ArrowUp"]) camera.position.addScaledVector(f,-0.1);
  if(key["ArrowDown"]) camera.position.addScaledVector(f,0.1);
  if(key["ArrowLeft"]) camera.position.addScaledVector(r,0.1);
  if(key["ArrowRight"]) camera.position.addScaledVector(r,-0.1);

  if(key["Space"] && onSurface){
    vy=0.22;
    onSurface=false;
  }

  vy-=0.01;
  camera.position.y+=vy;

  if(camera.position.y<1.8){
    camera.position.y=1.8;
    vy=0;
    onSurface=true;
  }

  renderer.
